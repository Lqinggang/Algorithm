## KMP字符串匹配算法  
吐槽一下, kMP算法真难理解(反正我还是不理解的,虽然貌似好像实现了)...   
从我的角度(半懂不懂的角度)想要理解KMP算法的话,我认为以下几点理解了,KMP算法就不难  
1)失配函数是什么?next数组是什么?  
2)怎么获得(生成)next数组?  
3)怎么使用next数组?  

####1.失配函数是什么?next数组是什么?  
失配函数是用于生成next数组的。next数组(在代码里面,我把它叫做失配数组)匹配串
的前后缀之间的匹配(...跳过这句话)  
例如:  
匹配串:aaxaa 对应的next数组为[0, 1, 0, 1, 2]  (有关前缀和后缀的知识,这里跳过)   
这样子应该更好看一些:  
```
['a', 'a', 'c', 'a', 'a']  
[ 0 ,  1 ,  0 ,  1 ,  2 ]  
```
在这里(我写的代码里)next数组表示的是当前字符失配时,匹配串应该从哪里开始重新匹配,
next表示的是对应的匹配串对应(差一点点对应)的下标  
  
例如:
主串:aaxaacaa,当i==2(主串下标索引,从0开始)且j==2(匹配串下标索引,从0开始)不匹配,即
c和x不匹配时,代表着匹配串中0到j-1是匹配的(不然到不了j==2),我们观察一下前面0到j-1
匹配的部分是:aa,嗯?aa?那我们是不是可以说至少j-1部分是匹配的,而j-1部分(后缀)又刚好
和0(前缀)匹配?  
  
aa可能不太好理解,换一个,假设主串为aaacaaax,匹配串为aaacaaad,则,对应的next数组为
[0, 1, 2, 0, 1, 2, 3, 0],当匹配到x和d时:
```  
['a', 'a', 'a', 'c', 'a', 'a', 'a', 'x']; i == 7
['a', 'a', 'a', 'c', 'a', 'a', 'a', 'd']; j == 7
```  
  
i==7(x)且j==7(d)的字符不匹配,按照朴素算法,此时,我们应该使j==0,i++从头开始比较,也就是这样子:
```  
['a', 'a', 'a', 'c', 'a', 'a', 'a', 'a', 'x']; i == 1
     ['a', 'a', 'a', 'c', 'a', 'a', 'a', 'a', 'd']; j == 0
```  
  
观察前面已经匹配的部分是aaaxaaa,我们可以很容易得出前缀aaa和后缀aaa已经匹配了,所以我们
下一次比较的时候前缀的那几个字符就不需要比较了,
```  
['a', 'a', 'a', 'c', 'a', 'a', 'a', 'a', 'x']; i == 1
                    ['a', 'a', 'a', 'c', 'a', 'a', 'a', 'a', 'd']; j == 3 --> next[ 7 - 1] == 3
``` 
所以:next其实就是告诉我们,当我们遇到一个失配的字符的时候，我们可以看看它已经匹配的部分
中前缀和后缀有多少字符是已经匹配的(这些前缀就不需要在比较了),下次比较的时候，只需要从
next[j - 1]所对应的匹配串下标值开始比较就行了(j == 0时表示前面的全部不匹配,匹配串需要从0开始,
主串需要从下一个字符开始比较)
  
####2.怎么获得(生成)next数组?
获得next数组?初始化next[0] == 0;剩下的就是比较前缀和后缀了,只需要保存两个下标索引:i表示前缀的下标,
j表示后缀的下标;
```
j =      1 
  ['a', 'a', 'a', 'c', 'a', 'a', 'a']
i =                          5

next[5] = (++j == 2);

```
  
####3.怎么使用next数组?  
使用朴素匹配算法进行匹配,遇到失配的字符则查找next数组中对应的next[j - 1]所表示的匹配串下一次
开始匹配的下标(j == 0时,i++)


### 注意
1)　不保证正确性(测试用例少,不全面,欢迎补充或指出错误加上可能存在的理解错误)  
2)　不保证效率
